package main

import (
	"io"
	"sort"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
	tsuruV1Config "github.com/tsuru/tsuru-client/tsuru/config"
	"github.com/tsuru/tsuru-client/v2/pkg/cmd"
)

var legacyTemplate = `// DO NOT EDIT THIS FILE MANUALLY.
// This file is auto-generated by cmd/gen/generate.go
// Run "go generate ./..." to regenerate it.

// Copyright Â© 2023 tsuru-client authors
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package legacy

import "strings"

var LegacyCommands = map[string]bool{
{{- range index . "legacy" }}
	"{{ . }}": true,
{{- end }}
}

var ModernCommands = map[string]bool{
{{- range index . "modern" }}
	"{{ . }}": true,
{{- end }}
}

func IsLegacyOnlyCommand(c string) bool {
	c = strings.ReplaceAll(c, "-", " ")
	return LegacyCommands[c] && !ModernCommands[c]
}
`

func iterateCobraCmdToSlice(c *cobra.Command, prefix string, commands *[]string) {
	if !c.Hidden && c.IsAvailableCommand() && !c.HasSubCommands() {
		*commands = append(*commands, prefix+c.Name())
	}
	for _, cmd := range c.Commands() {
		iterateCobraCmdToSlice(cmd, prefix+c.Name()+" ", commands)
	}
}

func genTsuruLegacy(out io.Writer) {
	tsuruLegacyCmd := tsuruV1Config.BuildManager("tsuru-legacy", "")
	tsuruCmd := cmd.NewRootCmd(nil, nil)

	modernCommands := []string{}
	for _, c := range tsuruCmd.Commands() {
		iterateCobraCmdToSlice(c, "", &modernCommands)
	}

	legacyCommands := make([]string, 0, len(tsuruLegacyCmd.Commands))
	for name := range tsuruLegacyCmd.Commands {
		legacyCommands = append(legacyCommands, strings.ReplaceAll(name, "-", " "))
	}

	sort.Slice(modernCommands, func(i int, j int) bool { return modernCommands[i] < modernCommands[j] })
	sort.Slice(legacyCommands, func(i int, j int) bool { return legacyCommands[i] < legacyCommands[j] })

	t := template.Must(template.New("legacy").Parse(legacyTemplate))
	t.Execute(out, map[string][]string{
		"modern": modernCommands,
		"legacy": legacyCommands,
	})
}
