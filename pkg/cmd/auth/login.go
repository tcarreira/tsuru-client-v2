// Copyright Â© 2023 tsuru-client authors
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package auth

import (
	"encoding/json"
	"fmt"
	"io"
	"net/url"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/tsuru/tsuru-client/internal/config"
	"github.com/tsuru/tsuru-client/internal/tsuructx"
	"golang.org/x/term"
)

type loginScheme struct {
	Name string
	Data map[string]string
}

func NewLoginCmd() *cobra.Command {
	loginCmd := &cobra.Command{
		Use:   "login [EMAIL]",
		Short: "initiates a new tsuru session for a user",
		Long: `Initiates a new tsuru session for a user. If using tsuru native authentication
scheme, it will ask for the email and the password and check if the user is
successfully authenticated. If using OAuth, it will open a web browser for the
user to complete the login.

After that, the token generated by the tsuru server will be stored in
[[${HOME}/.tsuru/token]].

All tsuru actions require the user to be authenticated (except [[tsuru login]]
and [[tsuru version]]).
`,
		Example: `$ tsuru login
$ tsuru login example@tsuru.local`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return loginCmdRun(cmd, args, tsuructx.GetTsuruContextSingleton())
		},
		Args: cobra.RangeArgs(0, 1),
	}

	return loginCmd
}

func loginCmdRun(cmd *cobra.Command, args []string, tsuruCtx *tsuructx.TsuruContext) error {
	cmd.SilenceUsage = true
	if viper.GetString("token") != "" {
		return fmt.Errorf("this command can't run with $TSURU_TOKEN environment variable set. Did you forget to unset?")
	}

	authScheme := &loginScheme{Name: tsuruCtx.AuthScheme}
	if authScheme.Name == "" {
		var err error
		authScheme, err = getAuthScheme(tsuruCtx)
		if err != nil {
			return err
		}
	}

	switch strings.ToLower(authScheme.Name) {
	case "oauth":
		return oauthLogin(tsuruCtx, authScheme)
	case "saml":
		return fmt.Errorf("login is not implemented for saml auth. Please contact the tsuru team")
	default:
		return nativeLogin(cmd, args, tsuruCtx)
	}
}

func getAuthScheme(tsuruCtx *tsuructx.TsuruContext) (*loginScheme, error) {
	request, err := tsuruCtx.NewRequest("GET", "/auth/scheme", nil)
	if err != nil {
		return nil, err
	}
	httpResponse, err := tsuruCtx.RawHTTPClient.Do(request)
	if err != nil {
		return nil, err
	}
	defer httpResponse.Body.Close()

	info := loginScheme{}
	err = json.NewDecoder(httpResponse.Body).Decode(&info)
	if err != nil {
		return nil, err
	}
	return &info, nil
}

func nativeLogin(cmd *cobra.Command, args []string, tsuruCtx *tsuructx.TsuruContext) error {
	var email string
	if len(args) > 0 {
		email = args[0]
	} else {
		fmt.Fprint(tsuruCtx.Stdout, "Email: ")
		fmt.Fscanf(tsuruCtx.Stdin, "%s\n", &email)
	}
	fmt.Fprint(tsuruCtx.Stdout, "Password: ")
	password, err := PasswordFromReader(tsuruCtx.Stdin)
	if err != nil {
		return err
	}
	fmt.Fprintln(tsuruCtx.Stdout)

	v := url.Values{}
	v.Set("password", password)
	b := strings.NewReader(v.Encode())
	request, err := tsuruCtx.NewRequest("POST", "/users/"+email+"/tokens", b)
	if err != nil {
		return err
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	httpResponse, err := tsuruCtx.RawHTTPClient.Do(request)
	if err != nil {
		return err
	}
	defer httpResponse.Body.Close()
	result, err := io.ReadAll(httpResponse.Body)
	if err != nil {
		return err
	}
	out := make(map[string]interface{})
	err = json.Unmarshal(result, &out)
	if err != nil {
		return err
	}
	fmt.Fprintln(tsuruCtx.Stdout, "Successfully logged in!")
	return config.SaveToken(out["token"].(string))
}

func PasswordFromReader(reader io.Reader) (string, error) {
	var (
		password []byte
		err      error
	)
	if desc, ok := reader.(tsuructx.DescriptorReader); ok && term.IsTerminal(int(desc.Fd())) {
		password, err = term.ReadPassword(int(desc.Fd()))
		if err != nil {
			return "", err
		}
	} else {
		fmt.Fscanf(reader, "%s\n", &password)
	}
	if len(password) == 0 {
		return "", fmt.Errorf("empty password. You must provide the password")
	}
	return string(password), err
}
